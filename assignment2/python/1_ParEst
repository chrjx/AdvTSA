import numpy as np
import numpy.random as npr
from scipy.optimize import minimize
import matplotlib.pyplot as plt

# --------------------------------------------------------------------
# 1. Simulate a SETAR(2,1,1) process (two regimes, AR(1) per regime)
# --------------------------------------------------------------------
def simulate_setar(
    T,
    c1=4.0, phi1=0.5, sigma1=1.0,
    c2=-4.0, phi2=-0.5, sigma2=1.0,
    threshold=0.0,
    delay=1,
    burn=200,
    y0=0.0,
    seed=None
):
    if seed is not None:
        npr.seed(seed)

    N = T + burn
    y = np.zeros(N + 1)
    y[0] = y0
    s = np.zeros(N + 1, dtype=int)

    for t in range(1, N + 1):
        lag_idx = max(0, t - delay)
        if y[lag_idx] <= threshold:
            s[t] = 1
            eps = npr.normal(0.0, sigma1)
            y[t] = c1 + phi1 * y[t-1] + eps
        else:
            s[t] = 2
            eps = npr.normal(0.0, sigma2)
            y[t] = c2 + phi2 * y[t-1] + eps

    return y[burn+1:], s[burn+1:]

# --------------------------------------------------------------------
# 2. Define the loss function Qn(θ) = sum_t (y_t - ŷ_t(θ))^2
# --------------------------------------------------------------------
def Qn(theta, y, c1, c2, threshold, delay):
    """Compute the prediction error loss for given φ₁, φ₂."""
    phi1, phi2 = theta
    n = len(y)
    rss = 0.0

    for t in range(1, n):
        lag_idx = max(0, t - delay)
        if y[lag_idx] <= threshold:
            yhat = c1 + phi1 * y[t-1]
        else:
            yhat = c2 + phi2 * y[t-1]
        rss += (y[t] - yhat) ** 2

    return rss

# --------------------------------------------------------------------
# 3. Simulation and Estimation
# --------------------------------------------------------------------
true_params = dict(
    c1=3.0, phi1=0.5, sigma1=1.0,
    c2=-3.0, phi2=-0.5, sigma2=1.0,
    threshold=-2.5, delay=1
)
T = 500
y, s = simulate_setar(T=T, burn=100, y0=0.0, seed=42, **true_params)

def objective(theta):
    return Qn(theta, y=y,
              c1=true_params['c1'], c2=true_params['c2'],
              threshold=true_params['threshold'], delay=true_params['delay'])

theta0 = np.array([0.1, -0.1])

res = minimize(objective, theta0, method='BFGS', options={'disp': True})

phi1_hat, phi2_hat = res.x
rss_min = res.fun

# --------------------------------------------------------------------
# 4. Compare with closed-form OLS
# --------------------------------------------------------------------
mask1 = np.array([(y[max(0, i-true_params['delay'])] <= true_params['threshold'])
                  for i in range(1, len(y))])
mask2 = ~mask1

y_lag = y[:-1]
y_t = y[1:]

phi1_ols = np.dot(y_lag[mask1], (y_t[mask1] - true_params['c1'])) / np.dot(y_lag[mask1], y_lag[mask1])
phi2_ols = np.dot(y_lag[mask2], (y_t[mask2] - true_params['c2'])) / np.dot(y_lag[mask2], y_lag[mask2])

# --------------------------------------------------------------------
# 5. Display results
# --------------------------------------------------------------------
print("\n--- SETAR(2,1,1) Parameter Estimation ---")
print(f"True values:       φ₁ = {true_params['phi1']:.3f}, φ₂ = {true_params['phi2']:.3f}")
print(f"Estimated (PEM):   φ₁ = {phi1_hat:.3f}, φ₂ = {phi2_hat:.3f}")
print(f"Closed-form (OLS): φ₁ = {phi1_ols:.3f}, φ₂ = {phi2_ols:.3f}")
print(f"Minimized RSS: {rss_min:.3f}")

# --------------------------------------------------------------------
# 6. Plot the simulated series and regime trace
# --------------------------------------------------------------------
fig, axs = plt.subplots(2, 1, figsize=(8, 6), constrained_layout=True)
axs[0].plot(y, lw=0.8, color="navy")
axs[0].set_title("Simulated SETAR(2,1,1) Time Series")
axs[0].set_ylabel("yₜ")

axs[1].step(np.arange(len(s)), s, where='post', color='darkorange')
axs[1].set_title("Regime Trace (1 = lower regime, 2 = upper regime)")
axs[1].set_xlabel("t")
axs[1].set_ylabel("Regime")

plt.show()
